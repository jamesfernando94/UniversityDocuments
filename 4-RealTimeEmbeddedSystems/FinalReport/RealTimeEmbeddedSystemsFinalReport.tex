\documentclass[a4paper,12pt]{scrartcl}
\input{documentSetup.tex}
\input{codeListingStyles.tex}

\graphicspath{ {images/} }
\usepackage[
	backend=biber,
	style=ieee,
	]{biblatex}

\addbibresource{references.bib}

\title{829H1 Real-Time Embedded Systems Final Report}
\author{Candidate No: 105936}
\date{\today}

\begin{document}
	
	\begin{titlepage}
		\maketitle
	\end{titlepage}
	
	\tableofcontents
	\newpage

	\section{Abstract}
	{
		The IoT space is full of applications and devices to make life easier this project has also been inspired by this trend. The main section of this report is how to connect the freedom K64F\cite{nxpproducts2014} to an external API and display text on the application shield. It looks into the process of displaying current weather information on the application shields display.
	}

	\section{Introduction}
	{
		This report focuses on using the FRDM-K64F\cite{nxpproducts2014} as a connected device to display weather information on the application shields display. Developing for real time systems relies on making sure that there is no delay or wait for the program in terms of using interrupts correctly and making sure the program runs quickly. I will start by going through the exercises I completed during the lab sessions before going on to how I created the weather application which runs on the board. 
	}
	
	\section{Exercises}
	{
		I conducted a number of exercises/experiments over the course of the term and learnt a number of ways in which the outputs of the board can be used and other programming constructs. In this section I will go over what was learnt and how it helped me with the project which was completed.
		\subsection{Parallel IO}
		{
			This was a relatively gentle introduction on programming for embedded systems. It allowed me to get used to how to use the mbed IDE and how developing for the board works. This exercise was based on direct programming where the binaries are complied to run on the specific hardware. This is sightly different from my background in programming for computers where a program is complied for an Operating system or some other intermediate interface between the program and the hardware. 
		}
		\subsection{Interrupt and Timers}
		{
			Although I did not use the timer functionality in the end for my project the interrupts were very useful and vital in my view for real time embedded systems as it is necessary for systems to be able to manage changes and be able to react to important information. I ended up using the interrupts feature to deal with the inputs from the joystick although I had to go further and use mbed events\cite{Jongboom2018} as well so that I was able to output to the various displays. This is because it is not possible to output to a serial communication from an interrupt.
		}
		\subsection{Power Width Modulation}
		{
			This exercise was not particularly useful when building my project however it does provide a good introduction on how motor and other devices work these provide a useful introduction on how to use the oscilloscope and work that would be completed in the next section.
		}
		\subsection{Serial Communications}
		{
			This helped cement knowledge about how serial communications work while also providing a bit of backround information on parallel communication. This was one of the more complicated exercise although did allow for the learning of a number of parts of serial communications such as what the different lines are used for. For example the clock line, MISO, MOSI. I was also able to learn about the different clock modes which would change when the data bits were sent compared to the clock line values. Although the usb mouse functionality was relatively interesting and provided a small insight on the number of features which are available on the board.
		}
		\subsection{Ethernet Connections}
		{
			This exercise taught me the basics about network communications and provided some of the basic idea for what I could do for my project. Also the IBM application clearly showed what sensors are available to be used.
		}
		
	}

	\section{Project}
	{
		\subsection{Getting the current public IP Address}
		{
			The first part of the program was to get the board to get it's own ip address allowing the board to query the location for the correct IP. To do this I needed to get the current public IP address of the board using the code \lstinline|EthernetInterface.getIPAddress()| unfortunately this only returned the internal IP address. Therefore, I had to use a public API to get the IP address for this I used \url{https://api.ipify.org}\cite{Degges}. To use this I would send off a http request to the address and then read the received text back. To send the http request I had to use the \url{https://os.mbed.com/teams/sandbox/code/mbed-http/} library simply importing this library didn't work therefore I had to fork the http examples repository found at \url{https://os.mbed.com/teams/sandbox/code/http-example/} and modify it for my purposes.
		}
		\subsection{Displaying on the LCD}
		{
			This was fairly simple to implement compared to the http library. As all I needed to do was import the library from \url{https://os.mbed.com/users/chris/code/C12832/} and use the example from \url{https://os.mbed.com/users/chris/code/app-shield-LCD/file/f8ef5e45e488/main.cpp/} as guidance on how to use the library. 
		}
		\subsection{Re-factoring the code}
		{
			After implementing the function to get the IP address and the display it to the screen I realised I would either have to change the layout of the code so that I could support the display of all of the information or just display one piece of information. I decided that the best way to go was to support displaying all of the information this meant that I would need to create a number of functions to manage what would be displayed and how to change the information on the display.
		}
		\subsection{Using the joystick to scroll through the display}
		{
			To make use of the joystick I only had to add \lstinline|InterruptIn joy_up(A2);| for up and down and then make use of the inputs for this. My initial plan was to use the interrupt to update the screens display however it is not possible to call serial communications from an interrupt meaning I cannot use the printf to the LCD or to the debug USB. To overcome this issue I need to use mbed events to do this I used information from the blog \url{https://os.mbed.com/blog/entry/Simplify-your-code-with-mbed-events/}\cite{Jongboom2018}. This would allow me to add functions to be called on a separate thread. After this I now had the basic layout of the system working so all I needed to do was to add functionality to get the location and then weather information.
		}
		\subsection{Getting the Location}
		{
			For this all I had to do was use the code from earlier to get the IP address but change the URL to an API which would get the location. I also needed to parse the result so that I could make use of the individual JSON values(I.E. the Latitude and Longitude values). to do this I used this library \url{https://os.mbed.com/users/samux/code/MbedJSONValue/} as it had some documentation on how to use it. This allowed me to relatively easily obtain the latitude and longitude as strings.
		}
		\subsection{Displaying the Weather Information}
		{
			After I had the obtained the coordinates All I needed to do was to use the API from \url{https://openweathermap.org/api} to get the weather information for the coordinates I obtained earlier. As I was able to display the temperature fairly quickly I decided on adding a description of the weather to the display. The  only slightly complicated thing was converting the temperature value from a double to a string to help me with this I searched stack overflow and found this result \url{https://stackoverflow.com/a/332132}\cite{Schaub2008}.
		}
	}
	
	\section{Analysis}
	{
		\subsection{Program Information/User Guide}
		{
			The idea of this program is that all you have to do is plug it in and it works the rest out for you. Therefore to get it working all you need to do is connect the USB and Ethernet and then wait for it to load information. You are able to scroll through the information before it loads but all it will read is \lstinline|waiting...| but it will refresh once the data is obtained.
		}
	}
	
	\section{Conclusion}
	{
		
	}
	
	\newpage
	\input{Appendix.tex}
	\printbibliography[heading=bibintoc,title=References]
\end{document}
